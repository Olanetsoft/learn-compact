pragma language_version >= 0.18.0;

// Note: Compact does not support type aliases. Use inline tuple types.
// A coordinate is represented as [Uint<32>, Uint<32>]

// TODO: Implement createCoordinate - returns a coordinate tuple
export pure circuit createCoordinate(x: Uint<32>, y: Uint<32>): [Uint<32>, Uint<32>] {
    // Return a tuple [x, y]
}

// TODO: Implement getX - extracts x (first element) from a coordinate
export pure circuit getX(coord: [Uint<32>, Uint<32>]): Uint<32> {
    // Return the first element
}

// TODO: Implement getY - extracts y (second element) from a coordinate
export pure circuit getY(coord: [Uint<32>, Uint<32>]): Uint<32> {
    // Return the second element
}

// TODO: Implement sumVector - sums all elements in a Vector<5, Uint<8>>
// Actual max sum = 5 * 255 = 1275, so return type is Uint<0..1275>
export pure circuit sumVector(v: Vector<5, Uint<8>>): Uint<0..1275> {
    // Sum all 5 elements: v[0] + v[1] + v[2] + v[3] + v[4]
    // No casts needed - Uint<8> addition stays bounded
}

// TODO: Implement swapCoordinate - swaps x and y
export pure circuit swapCoordinate(coord: [Uint<32>, Uint<32>]): [Uint<32>, Uint<32>] {
    // Extract elements using index access and return swapped
    // Return [y, x]
}
