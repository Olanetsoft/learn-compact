pragma language_version >= 0.18.0;

import CompactStandardLibrary;

// Exercise 1: Create a structural type alias
// Define a structural alias called Point for [Field, Field]

// YOUR CODE HERE: Define the Point type alias


// Exercise 2: Use the structural alias
// Implement a circuit that creates a Point at origin (0, 0)

export pure circuit origin(): Point {
    // YOUR CODE HERE
}


// Exercise 3: Create a nominal type alias
// Define a nominal alias called UserId for Uint<64>

// YOUR CODE HERE: Define the UserId new type


// Exercise 4: Create a value with nominal type
// Implement a circuit that takes a Uint<64> and returns it as a UserId

export pure circuit createUserId(id: Uint<64>): UserId {
    // YOUR CODE HERE (hint: use "as" to cast)
}


// Exercise 5: Arithmetic with nominal types
// Implement a circuit that increments a UserId by 1
// Remember: nominal types require explicit casting for arithmetic

export pure circuit incrementUserId(id: UserId): UserId {
    // YOUR CODE HERE
}


// Exercise 6: Multiple nominal types
// Define two nominal types:
// - AccountId = Bytes<32>
// - TokenId = Bytes<32>
// Then create a struct Transfer with fields: from (AccountId), to (AccountId), tokenId (TokenId)

// YOUR CODE HERE: Define AccountId, TokenId, and Transfer


// Exercise 7: Generic type alias
// Define a generic structural alias called Pair<T> for [T, T]

// YOUR CODE HERE: Define the Pair<T> type alias


// Exercise 8: Use generic alias
// Implement a circuit that swaps a Pair<Field>

export pure circuit swapPair(p: Pair<Field>): Pair<Field> {
    // YOUR CODE HERE
}
